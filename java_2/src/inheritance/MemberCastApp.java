package inheritance;

//상속관계의 클래스에서 참조변수와 객체와의 관계
public class MemberCastApp {
	public static void main(String[] args) {
		//부모클래스 참조변수 = new 부모클래스();
		//=> 부모클래스의 생성자로 개체를 생성하여 부모클래스의 참조변수에 저장
		Member member1 = new Member();
		
		//참조변수에 저장된 부모클래스의 객체를 사용하여 부모클래스의 메소드를 호출할 수 있다.
		member1.setId("abc123");
		member1.setName("홍길동");
		
		member1.display();
		
		System.out.println("=================================================================");
		
		//만들어진 객체를 자식클래스의 참조변수에 저장한다.
		//자식클래스 참조변수 = new 자식클래스();
		//=> 부모클래스의 생성자로 부모클래스 객체를 생성하고, 자식클래스의 생성자로 자식클래스 객체를 생성하여,(->여기까지 총 2개의 객체가 만들어진것) 자식클래스의 참조변수에 자식클래스의 객체를 저장한다. 
		
		MemberEvent member2 = new MemberEvent();
		
		//참조변수에 자식을 집어넣어서 자식을 참조하고, 자식을 통해 부모도 참조 가능함.(상속때문에)
		
		//참조변수에 저장된 자식클래스의 객체를 사용하여 자식클래스의 메소드를 호출할 수 있으며, 상속관계에 의해 부모클래스 객체를 참조하여 부모클래스도 호출가능.
		//따라서, 여기서는 MemberEvent와 Member 모두 호출 가능.
		member2.setId("xyz789");
		member2.setName("임꺽정");
		member2.setEmail("xyz@itwill.com"); 
		
		member2.display();
		
		System.out.println("=================================================================");
		
		//여기까지가 일반적인 방법
		
		System.out.println("=================================================================");
		
		//If1.
		//자식클래스 참조변수 = new 부모클래스();
		//=> 부모클래스의 생성자로 부모클래스 객체를 생성하고 자식클래스의 참조변수에 부모클래스의 객체저장
//		MemberEvent member3 = new Member(); 	//=> 실행불가!(에러발생) 메모리에는 부모클래스의 객체만 저장이 되었는데 메모리주소는 자식클래스의 주소를 저장해야하는데 자식클래스 객체는 생성이 안되었기때문에 메모리 주소에 저장할 수 있는 값이 없음
		
		System.out.println("=================================================================");
		
		//If2.
		//부모클래스 참조변수 = new 자식클래스();
		//=> 부모클래스의 생성자로 부모클래스 객체를 생성하고 부모클래스의 참조변수에 자식클래스의 객체저장
		Member member4 = new MemberEvent(); 	//=> 실행가능0 (부모클래스에 객체가 있고 그것을 참조변수에 저장하는 것이므로가능. 단, 자식은 참조할 수 없음.)
		
		member4.setId("opq456");	
		member4.setName("전우치");
//		member4.setEmail("opq@itwill.com");		//=> MemberEvent는 참조할 수 없다. (자식클래스의 객체를 참조 할 수 없으므로 자식클래스의 메소드는 호출 할 수 없다.)

		
	
		//** 객체 형변환을 이용하면 부모클래스의 참조변수로 자식클래스의 메소드를 호출할 수 있다.(원래는 안되는데 강제 형변환이라서)
		//=> 명시적 객체 형변환(강제 형변환), 묵시적 객체 형변환(자동 형변환)
		//=> 상속관계의 클래스에서만 객체 형변환 사용가능
		
		//명시적 객체 형변환 : Cast 연산자를 사용하여 부모클래스의 참조변수의 자료형을 일시적으로 자식클래스로 변경하면 참조변수에 자식클래스의 객체가 자동 저장
		//=> 명시적 객체 형변환에 의해 자식클래스로 자료형이 변경된 참조변수는 자식클래스의 객체가 저장되므로 자식클래스의 메소드가 호출이 될 수 있다.
		//방법1
//		MemberEvent event = (MemberEvent)member4;	//member4에는 부모클래스 객체가 저장되어 있지만 명시적 객체 형변환으로 인해 일시적으로 자식클래스의 참조변수에 저장.
//		event.setEmail("opq@itwill.com");
		//방법2		
//		(MemberEvent)member4.setEmail();	//단항연산자보다 .연산자가 먼저 실행이 되어서 에러
		((MemberEvent)member4).setEmail("opq@itwill.com");
		
		//((MemberEvent)member4).display();
		member4.display(); //아이디, 이름, 이메일까지 모두 출력됨-왜? >> 묵시적 객체 형변환이 일어나기 때문.
		
		//묵시적 객체 형변환 : 부모클래스의 메소드를 자식클래스에서 오버라이드 선언하면, 부모클래스의 메소드는 숨겨지고 자식클래스에 메소드를 호출하기위해 참조변수의 자료형을 자동으로 자식클래스로 변경하여 자식클래스의 객체가 일시적으로 자식클래스의 객체가 참조변수에 저장되어 자식클래스의 메소드 호출된다.
		
		
		//상속관계가 1:1일경우, 형변환 없이 생성자 생성해서 자식메소드를 호출하는 것이 편함. (ex.member2)
		//하지만 상속관계가 [부모:자식 = 1:n]인 경우 형변환을 해야함. (형변환을 이용하면 부모를 통해 모든 자식클래스의 메소드를 참조가능)
		//따라서, 참조변수는 무조건 부모를 가지고만들고, 객체는 자식을 가지고 만들어야함.
	}

}
